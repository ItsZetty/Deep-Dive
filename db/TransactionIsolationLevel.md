# Transaction Isolation Level

트랜잭션의 격리 수준은 일단 ACID 중 I(Isolation)에 관한 개념입니다.

>**Isolation이란?** <br>
>"실행되고 있는 트랜잭션들은 서로에게 영향을 주지 않는다." 라는 개념을 갖고 있습니다. <br>
>이는 즉, "트랜잭션들이 독립적으로 실행되는 것처럼 보이게 만든다" 와 같은 의미입니다. <br>
>이를 위해 MySQL은 격리 수준을 제공합니다. 

트랜잭션의 격리 수준은 동시에 여러 트랜잭션이 실행될 때 한 트랜잭션이 다른 트랜잭션의 연산에 영향을 받지 않도록 하는 정도를 말합니다. 

낮은 격리 수준은 동시 처리 능력을 높이지만, 데이터의 일관성 문제를 발생시킬 수 있습니다. 반면, 높은 격리 수준은 데이터의 일관성을 보장하지만, 동시 처리 능력이 떨어질 수 있습니다. 

즉, 데이터 정합성과 성능은 반비례합니다. 트랜잭션 격리 수준은 개발자가 트랜잭션 격리 수준을 설정할 수 있는 기능을 제공하는 기능입니다.

## 🤷🏻‍♂️ 트랜잭션 격리 수준은 어떤 것이 있고 각각 어떤 특징이 있나요?

트랜잭션 격리 수준은 `READ UNCOMMITTED`, `READ COMMITTED`, `REPEATABLE READ`, `SERIALIZABLE`가 존재합니다.

**1️⃣ `READ UNCOMMITTED`** <br>
커밋되지 않은 데이터에도 접근할 수 있는 격리 수준입니다.

이때 `Dirty Read` 문제가 발생할 수 있습니다.

이는 만약 중간에 데이터가 롤백이 되더라도, 다른 곳에서 이미 조회를 한 상태이며 문제가 발생합니다.


**2️⃣ `READ COMMITTED`** <br>
커밋된 데이터에만 접근할 수 있는 격리 수준입니다.

만약 A라는 데이터를 UPDATE를 시도한다면, 테이블에 변경되는 동시에 Undo Log 파일에 수정 전 데이터가 저장되게 됩니다.

변경 사항을 커밋 전, 만약 다른 곳에서 A를 조회하게 된다면, 테이블이 아닌 Undo Log에서 데이터를 가져오게 됩니다. 

그 이유는 "커밋된 데이터"만 접근할 수 있기 때문입니다.

이때 `Non-Repeatable Read` 문제가 발생할 수 있습니다.


**3️⃣ `REPEATABLE READ`** <br>
동일한 행을 여러 번 읽어도 항상 같은 결과를 보장하는 트랜잭션 격리 수준입니다.

이는 MySQL InnoDB에서 표준 격리 수준으로 사용하고 있습니다.

하나의 트랜잭션에는 트랜잭션 번호가 부여되며, 순차적으로 증가하게 됩니다. 그리고 데이터 행에는 변경을 발생시킨 트랜잭션 번호가 포함되게 됩니다.

`REPEATABLE READ`에서는 데이터를 불러올 때, 자신의 트랜잭션 번호보다 작은 트랜잭션 번호에서 변경한 것만 보게 됩니다. 그렇기 때문에 같은 행을 조회했을 때, 같은 결과 값을 가져옵니다.

하지만 이 격리 수준에도 문제점은 존재합니다.

만약 한 트랜잭션에서 SELECT FOR UPDATE를 통해 id > 4인 데이터를 조회했다고 가정해 봅시다. 그리고 다른 트랜잭션에서 INSERT를 통해 id=8인 데이터를 추가했다고 가정해 봅시다.

SELECT FOR UPDATE는 해당 조회된 데이터의 UPDATE는 막을 수 있지만, INSERT는 막지 못합니다.

그래서 데이터는 추가되며, 이후 다시 SELECT FOR UPDATE 조회를 한다면 Undo Log가 아닌 테이블에서 데이터를 읽어옵니다.

> 💡 **SELECT FOR UPDATE는 Undo Log까지 잠글 수는 없기에 테이블 조회를 합니다.**

결과적으로 새로 추가된 데이터까지 읽어오는 문제가 발생합니다. 이를 `Phantom Read`라고 말합니다.

> 💡 **하.지.만. MySQL InnoDB에서 발생한 SELECT FOR UPDATE는 Gap Lock을 사용하여 id > 4 범위의 갭에 INSERT를 막아줍니다. <br> 즉, MySQL InnoDB에서는 `Phantom Read` 문제가 발생하지 않습니다.**

**4️⃣ `SERIALIZABLE`** <br>
한 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서 절대 접근할 수 없는 트랜잭션 격리 수준입니다. 즉, 모든 읽기/쓰기에 잠금을 겁니다. 따라서 동시성이 매우 떨어지는 특징이 있습니다.

이는 하지만 이전에 발생했던 문제들이 발생하지 않습니다.

## 🤷🏻‍♂️ 그래서 각각의 문제들이 어떤 걸 의미하나요?
**1️⃣ `Dirty Read`** <br>
어떤 트랜잭션에서 처리한 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있는 현상입니다.

**2️⃣ `Non-Repeatable Read`** <br>
같은 트랜잭션 내에서 같은 행을 반복해서 읽었을 때, 다른 트랜잭션이 그 행을 수정하거나 삭제하여 결과가 달라지는 현상입니다.

**3️⃣ `Phantom Read`**  <br>
같은 트랜잭션 내에서 동일한 쿼리를 반복 실행했을 때, 다른 트랜잭션에 의해 새로운 데이터 행이 삽입되거나, 기존 데이터 행이 삭제되는 현상입니다.

## 📚 참고 자료
https://www.youtube.com/watch?v=QHWwNTGkwAU&t=29s