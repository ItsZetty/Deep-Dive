# InnoDB

**InnoDB**는 MySQL의 스토리지 엔진 중 하나로, 트랜잭션을 지원하는 ACID 호환 스토리지 엔진입니다.

InnoDB는 높은 성능과 안정성을 제공합니다.

> **스토리지 엔진이란?** <br>
> 데이터베이스에서 데이터를 어떻게 저장하고, 어떻게 접근할지를 결정하는 핵심 컴포넌트입니다. <br>
> MySQL5.5 전에는 InnoDB 전에 MyISAM를 기본적으로 사용했습니다. 이에 대해서는 아래에서 더 알아보겠습니다.

## 🤷🏻‍♂️ InnoDB는 어떤 특징을 가지고 있나요?

### 1. ACID 트랜잭션 지원
InnoDB는 완전한 ACID 트랜잭션을 지원합니다.

**ACID 특성**
- **Atomicity (원자성)**: 트랜잭션의 모든 작업이 성공하거나 모두 실패합니다.
- **Consistency (일관성)**: 데이터베이스가 항상 일관된 상태를 유지합니다.
- **Isolation (격리성)**: 동시에 실행되는 트랜잭션들이 서로 영향을 주지 않습니다.
- **Durability (지속성)**: 커밋된 트랜잭션은 영구적으로 저장됩니다.

### 2. 외래 키 제약 조건 지원
InnoDB는 외래 키 제약 조건을 지원하여 데이터 무결성을 보장합니다.

```sql
CREATE TABLE orders (
    id INT PRIMARY KEY,
    user_id INT,
    FOREIGN KEY (user_id) REFERENCES users(id)
);
```

### 3. 행 단위 잠금 (Row-Level Locking)
InnoDB는 행 단위 잠금을 사용하여 동시성을 향상시킵니다.

**잠금 유형**
- **Shared Lock (S-Lock)**: 읽기 잠금
- **Exclusive Lock (X-Lock)**: 쓰기 잠금
- **Intention Lock**: 테이블 레벨 잠금

### 4. 클러스터형 인덱스
InnoDB는 클러스터형 인덱스를 사용하여 데이터를 저장합니다.

> **클러스터형 인덱스란?** <br>
> 데이터베이스에서 테이블의 물리적 저장 순서를 결정하는 인덱스입니다.

**특징**
- 기본 키(Primary Key)가 클러스터형 인덱스로 사용됩니다.
- 데이터가 기본 키 순서로 물리적으로 정렬되어 저장됩니다.
- 기본 키가 없으면 자동으로 생성됩니다.

## 🤷🏻‍♂️ InnoDB의 구조는 어떻게 되어 있나요?

### 1. 버퍼 풀 (Buffer Pool)
- 메모리 기반 캐싱으로 I/O 성능 향상
- 데이터 페이지, 인덱스 페이지, 잠금 정보 저장

### 2. 리두 로그 (Redo Log)
- 커밋된 트랜잭션의 변경 사항 기록
- 장애 복구에 사용

### 3. 언두 로그 (Undo Log)
- 트랜잭션 롤백과 MVCC 지원
- 이전 데이터 상태 보존

### 4. 테이블스페이스 (Tablespace)
- 각 테이블의 데이터와 인덱스를 `.ibd` 파일에 저장

## 🤷🏻‍♂️ MyISAM에 대해서도 궁금해요.

**MyISAM**은 MySQL의 전통적인 스토리지 엔진으로, MySQL 5.5 이전까지 기본 스토리지 엔진이었습니다.

### MyISAM의 핵심 특징

**1. 트랜잭션 미지원**
- ACID 트랜잭션을 지원하지 않습니다.
- 각 SQL 문이 독립적으로 실행됩니다.

**2. 테이블 단위 잠금**
- 행 단위가 아닌 테이블 단위로 잠금을 수행합니다.
- 동시성이 떨어지지만, 구현이 단순합니다.

**3. 힙 테이블 구조**
- 클러스터형 인덱스를 사용하지 않습니다.
- 데이터를 삽입 순서대로 저장합니다.

**4. 파일 분리 저장**
- `.MYD` 파일: 데이터 저장
- `.MYI` 파일: 인덱스 저장

### InnoDB vs MyISAM 비교

| 특징 | InnoDB | MyISAM |
|------|--------|--------|
| 트랜잭션 지원 | ✅ | ❌ |
| 외래 키 지원 | ✅ | ❌ |
| 잠금 방식 | 행 단위 | 테이블 단위 |
| 인덱스 타입 | 클러스터형 | 비클러스터형 |
| 데이터 정렬 | 기본키 순서 | 삽입 순서 |
| 크래시 복구 | ✅ | ❌ |
| 읽기 성능 | 보통 | 빠름 |
| 쓰기 성능 | 빠름 | 보통 |

## 🤷🏻‍♂️ 그럼 MyISAM 말고 무조건 InnoDB를 써야 하나요?

꼭 그렇지는 않습니다. 각각의 상황에 따라 유동적으로 사용하면 좋을 것 같습니다.

InnoDB도 단점이 존재합니다. 이를 알아보기 위해 InnoDB의 행 단위 잠금에 대해서 이야기하겠습니다.

### InnoDB의 잠금 방식
InnoDB는 사실 직접적으로 행을 찾아서 잠그는 것이 아닌, 인덱스를 통해 특정 행을 찾아서 잠급니다. 그렇기 때문에 만약 WHERE 조건에 맞는 인덱스가 없다면, 테이블 풀스캔을 수행하고 모든 행을 잠그게 됩니다.

위와 같은 상황이 발생한다면, MyISAM과 유사한 상황이 발생됩니다.

**예시 상황**
> employees 테이블에는 first_name 칼럼만 인덱스를 걸어둔 상황입니다. <br>
그리고 employees 테이블에서 first_name='K'인 사원은 전체 253명이 있으며, first_name='K'이고, last_name='WY'인 사원은 딱 1명만 있습니다.

위 상황에서 아래 UPDATE 문을 실행해 보겠습니다.

```sql
UPDATE employees SET hire_date=NOW() WHERE first_name='K' AND last_name='WY';
```

결과적으로 1건의 레코드가 수정되겠지만, 이 1건의 수정을 위해 `first_name='K'`인 253건의 레코드가 모두 잠그게 됩니다.

만약 `first_name` 조차 인덱스를 걸어두지 않았다면, 테이블을 풀스캔하면서 UPDATE 작업을 하게 되어서 테이블에 있는 모든 레코드를 잠그게 됩니다.

그렇기 때문에 InnoDB도 적절한 인덱스가 없으면, MyISAM과 마찬가지로 테이블 전체를 잠그게 됩니다. 그렇기에 적절한 상황에 맞춰서 유동적으로 바꿀 필요가 있습니다.

**MyISAM 사용하는 경우**
- 읽기 중심의 데이터 (로그, 통계)
- 트랜잭션이 불필요한 경우
- 전체 테이블 스캔이 많은 경우

**MyISAM 사용하지 않는 경우**
- 트랜잭션이 필요한 경우
- 동시 쓰기가 많은 경우

## 💡 결론
InnoDB는 트랜잭션과 데이터 무결성을 보장하면서도 높은 성능을 제공하는 현대적인 스토리지 엔진입니다.

## 📚 참고 자료
https://www.youtube.com/watch?v=IftfkVSzOdI
https://velog.io/@wony_k/InnoDB-engine-lock