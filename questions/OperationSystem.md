# Operation System Questions

## 🤷🏻‍♂️ 고성능 서버 애플리케이션을 개발할 때 스레드 풀을 사용할 때의 장단점과, 실제 프로젝트에서 스레드 풀이 오히려 성능을 저하시켰던 경험이 있다면 설명해 주세요.

### 🙆🏻‍♂️ 답변
> 스레드 풀은 스레드 생성과 소멸의 오버헤드를 줄여 성능 최적화를 도와줍니다. 그러나 부적절한 스레드 풀 크기는 자원 고갈을 초래할 수 있습니다. 과거에 스레드 풀을 너무 작게 설정하여 요청 병목 현상이 발생했습니다. 이 문제를 해결하기 위해 서버 로드 테스트를 통해 적절한 스레드 풀 크기를 찾아 조정했습니다.

## 🤷🏻‍♂️ 그럼 스레드 풀 크기를 너무 많이 잡으면 어떤 문제가 있는지 설명해 주세요.

### 🙆🏻‍♂️ 답변
> 스레드가 너무 많으면 세 가지 문제가 발생합니다. 먼저 스레드끼리 자주 문맥 전환이 일어나서 오히려 성능이 떨어질 수 있습니다. 그리고 스레드 하나당 메모리를 점유하기 때문에, 스레드가 많아질수록 메모리 자원도 고갈될 위험이 있습니다. 마지막으로 공유 자원 접근 시, 동기화로 병목이 발생해 성능 저하가 일어날 수 있습니다. <br>그렇기 때문에 핵심은 스레드 풀을 무조건 늘리기 보다는, 서버 자원(CPU, 메모리)과 작업 성격(I/O 바운드인지 CPU 바운드인지)에 맞게 적절히 결정하는 것이 중요합니다.

### 🔑 키워드
> 운영체제, 스레드 풀, 성능 최적화, 병목 현상, 서버 로드 테스트, 자원 관리

<hr>

## 🤷🏻‍♂️ 마이크로서비스 아키텍처 환경에서 여러 프로세스가 독립적으로 실행될 때, 프로세스 간 통신을 효과적으로 관리하기 위한 전략은 무엇이며, 이를 적용한 경험이 있나요?

### 🙆🏻‍♂️ 답변
> 마이크로서비스에서 프로세스 간 통신은 메시지 브로커를 활용해 해결했습니다. RabbitMQ를 사용하여 서비스 간의 메시징을 비동기적으로 처리했습니다. 이를 통해 시스템의 확장성과 응답성을 동시에 향상시킬 수 있었습니다. 장애 상황에서도 메시지가 유실되지 않도록 큐의 내구성을 높이는 설정을 적용했습니다.

### 🔑 키워드
> 운영체제, 마이크로서비스, RabbitMQ, 메시지 브로커

<hr>

## 🤷🏻‍♂️ 대규모 트래픽을 처리하는 서버에서 메모리 누수가 발생했을 때, 이를 신속하게 진단하고 해결한 경험이 있습니까? 구체적인 상황과 그 과정에서 내린 결정을 설명해 주세요.

### 🙆🏻‍♂️ 답변
> 대규모 트래픽을 처리하는 서비스에서 메모리 사용량이 급증하여 서버가 불안정해졌습니다. 이를 해결하기 위해 메모리 프로파일링을 통해 문제의 함수와 객체를 식별하고, GC 튜닝 및 불필요한 객체 해제를 통해 메모리 누수를 해결했습니다. 그 과정에서 코드 리뷰를 통해 팀원들과 공유하며 유사한 문제가 재발하지 않도록 예방 조치를 강화했습니다.

### 🔑 키워드
> 운영체제, 메모리 누수, 프로파일링, GC 튜닝

<hr>

## 🤷🏻‍♂️ 서비스를 운용 중 데이터베이스의 레이스 컨디션 문제로 인해 데이터 불일치가 발생했습니다. 이 문제를 해결하기 위한 동기화 전략을 설명하고, 실제로 어떻게 적용했는지를 구체적인 사례로 답변해주세요.

### 🙆🏻‍♂️ 답변
> 과거에 사용자의 포인트 적립 시스템에서 레이스 컨디션으로 인해 동일한 포인트가 두 번 적립되는 문제가 발생했습니다. 이를 해결하기 위해 데이터베이스의 트랜잭션을 활용하여 포인트 업데이트 시 Lock을 적용하였습니다. 이로 인해 동시 접근 시 하나의 프로세스만 업데이트를 진행할 수 있게 되었고, 문제를 해결했습니다. 이후 모니터링을 통해 문제 재발 여부를 지속적으로 확인했습니다.

### 🔑 키워드
> 운영체제, 레이스 컨디션, 트랜잭션, 데이터 동기화

<hr>

## 🤷🏻‍♂️ 최근 당신의 팀에서 대규모 트래픽 증가로 인해 서버 메모리 부족 문제가 발생했다고 가정해봅시다. 메모리 자원을 최적화하기 위해 어떤 전략을 사용했고, 그 결정이 어떻게 문제를 해결했는지 설명해 주세요.

### 🙆🏻‍♂️ 답변
> 우리는 메모리 부족 문제를 해결하기 위해 JVM 메모리 관리를 최적화했습니다. 우선, GC 튜닝을 통해 메모리 사용 효율성을 개선했고, 필요하지 않은 객체의 생성을 억제했습니다. 또한, 캐싱 전략을 재검토하여 과도한 메모리를 차지하지 않도록 조정했습니다. 이러한 조치로 서버의 응답 시간이 줄어들고 안정성이 향상되었습니다.

### 🔑 키워드
> 운영체제, 메모리 최적화, GC 튜닝, 캐싱 전략

<hr>

## 🤷🏻‍♂️ 다중 스레드를 사용하는 애플리케이션에서 스레드 안전성을 보장하기 위해 어떤 도구나 기법을 사용했는지, 그리고 그로 인해 발생한 문제를 어떻게 해결했는지 설명해주세요.

### 🙆🏻‍♂️ 답변
> 서비스 운영 중 데이터 무결성이 깨지는 문제를 경험했습니다. 이를 해결하기 위해 Java의 `synchronized` 키워드를 사용해 임계 구역을 보호했습니다. 하지만 성능 저하가 발생했고, 이후 `ReentrantLock`을 사용하여 더 세밀한 제어를 통해 성능을 개선할 수 있었습니다. 이러한 경험을 통해 스레드 안전성과 성능 간의 균형을 맞추는 것이 중요하다는 것을 배웠습니다.

### 🔑 키워드
> 운영체제, 스레드 안전성, synchronized, ReentrantLock

<hr>

## 🤷🏻‍♂️ 여러분이 관리하는 백엔드 서비스에서 스레드 풀의 크기가 잘못 설정되어 발생한 성능 문제를 해결한 경험이 있다면, 그 과정에서 어떤 결정을 내렸고, 그 결정이 어떤 결과를 가져왔는지 설명해주세요.

### 🙆🏻‍♂️ 답변
>  한 번은 서비스의 응답 속도가 느려지면서 원인을 조사한 결과, 스레드 풀이 너무 작게 설정되어 요청 처리가 지연되고 있었습니다. 스레드 풀 크기를 동적으로 조정할 수 있도록 설계 변경을 하고, 피크 시간대에 맞춰 적정 크기로 설정했습니다. 이로 인해 응답 시간이 개선되었고, 리소스 사용 효율도 높아졌습니다. 이를 통해 시스템 성능을 모니터링하며 지속해서 최적화할 수 있었습니다.

### 🔑 키워드
> 운영체제, 스레드 풀, 성능 최적화, 리소스 관리

<hr>