# Sync and Async

동기와 비동기는 호출하는 함수의 작업 완료를 기다리는지 여부의 차이가 있습니다. 

그래서 동기는 요청을 보냈을 때, 응답이 올 떄까지 기다리는 개념이며, 비동기는 요청을 보냈을 때, 응답을 기다리지 않고 바로 다음 작업을 실행하는 개념입니다.

예를 들어, 함수 A가 동기로 함수 B를 호출하면 A는 B의 작업이 완료될 때까지 기다려야 합니다. 따라서 작업이 순차적으로 진행됩니다. 

반면, 함수 A가 비동기로 함수 B를 호출하면 A는 B의 작업 완료를 신경 쓰지 않고 따로 동작합니다. 따라서 작업이 순차적으로 진행되지 않습니다.


## 🤷🏻‍♂️ 그럼 블로킹과 논블로킹은 무엇인가요?
블로킹과 논블로킹은 요청한 작업이 완료될 때까지 제어권을 넘겨받을 수 있는가에 대한 개념입니다. 그래서 블로킹은 작업이 끝날 때까지 해당 스레드가 멈추는 방식이고, 논블로킹은 작업 결과와 관계없이 즉시 다음 코드를 실행할 수 있는 방식입니다.

## 🤷🏻‍♂️ 블로킹과 동기는 어떤 차이가 있나요?
동기 호출에서는 호출된 함수가 작업을 완료할 때까지 호출한 함수가 기다립니다. 즉, 작업이 순차적으로 진행되는 것을 의미합니다. 

반면, 블로킹은 함수가 호출된 후, 호출한 함수의 결과를 기다리기 위해 실행을 멈추는 상태를 의미합니다. 즉, 제어권이 반환되지 않고 대기하는 상황입니다.

## 🤷🏻‍♂️ 동기+블로킹, 동기+논블로킹, 비동기+블로킹, 비동기+논블로킹을 각각 개념과 상황을 설명해 주세요.
`동기+블로킹`은 가장 기본적인 방식입니다. 요청을 보내고 작업이 끝날 때까지 스레드가 멈춰 기다리면서 흐름도 막힙니다.
대표적으로 파일 읽기나 전통적인 HTTP 통신이 여기에 해당합니다.

`동기+논블로킹`은 요청 흐름은 동기지만, 중간 작업은 스레드를 막지 않고 바로 결과를 주는 방식입니다. 예를 들어 데이터가 준비되지 않았으면 바로 예외나 빈 값을 반환하는 식입니다. 흔하지는 않지만 특수한 라이브러리에서는 볼 수 있습니다.

`비동기+블로킹`은 요청은 비동기로 던졌지만, 나중에 결과를 받을 때 스레드가 기다리는 상황입니다. 예를 들어 비동기로 API 요청을 보냈지만, 그 결과를 `Future.get()` 같은 걸로 꺼낼 때는 블로킹될 수 있습니다.

`비동기+논블로킹`은 요청도 비동기고, 처리도 논블로킹으로 진행되는 이상적인 구조입니다. 대표적으로 WebFlux나 Netty 같은 논블로킹 네트워크 프레임워크가 여기에 해당합니다. 이 경우 스레드가 멈추지 않고 계속 다른 요청을 처리할 수 있습니다.

정리하면, `비동기+논블로킹`이 가장 효율적인 구조이고, 서버 성능 최적화에서도 주로 이 방식을 지향합니다.

>`동기+블로킹` : A 스레드가 A 요청을 보내고, 응답을 받을 때까지 가만히 멈춘다. <br>
`동기+논블로킹` : A 스레드가 A 요청을 보내고, 다른 B 작업을 하다가 A 응답이 오면 직접 처리한다. <br>
`비동기+논블로킹` : A 스레드가 A 요청을 보내고, 신경 끄고 자유롭게 일하다가 B 스레드가 A 응답을 처리한다. <br>
`비동기+블로킹` : 요청은 비동기지만, 응답을 기다리느라 스레드가 묶인다. 실무에서는 거의 안 쓴다. <br>