# Concurrency

동시성이란 이름처럼 실제로 여러 작업을 동시에 수행하는 것이 아니라, 논리적으로 동시에 실행되는 것처럼 보이게 만드는 개념입니다. 단일 코어를 기준으로 시간 분할을 통해 여러 스레드를 번갈아 가며 작업을 수행함으로써, 마치 동시에 여러 작업이 처리되는 것처럼 보이게 합니다.

사용자의 입력을 기다리거나, 네트워크 요청, 파일 입출력 등의 I/O 작업 시에는 CPU가 유휴 상태로 대기하게 됩니다. 이때 CPU가 아무 일도 하지 않고 대기하는 대신, 컨텍스트 스위칭을 통해 다른 스레드의 작업을 처리할 수 있습니다. 이러한 특성 덕분에 서버는 여러 클라이언트의 요청을 동시에 처리할 수 있어 효율적입니다. 다만, 동시성 환경을 신중하게 고려하지 않으면 여러 스레드를 사용하면서 Deadlock, Race Condition, Starvation 등의 문제가 발생할 수 있습니다.

>**Deadlock이란?** <br>
>두 개 이상의 프로세스나 스레드가 서로가 가진 자원을 기다리며 무한정 대기하는 상태입니다. 
>
>예를 들어, A가 B의 자원을, B가 A의 자원을 기다리는 상황입니다.

>**Race Condition이란?** <br>
>여러 프로세스나 스레드가 동시에 공유 자원에 접근할 때, 실행 순서에 따라 결과가 달라지는 상황입니다. 
>
>예를 들어, 두 스레드가 동시에 같은 변수를 수정할 때입니다.

>**Starvation이란?** <br>
>특정 프로세스나 스레드가 계속해서 자원을 할당받지 못해 무한정 대기하는 상태입니다. 
>
>예를 들어, 우선순위가 낮은 프로세스가 계속 실행되지 않는 상황입니다.

## 🤷🏻‍♂️ 동시성 제어 방식에는 무엇이 있나요?

동시성 제어 방식은 크게 **Lock 기반 방식**, **Lock-free 방식**, 그리고 **데이터베이스 락 방식**으로 나뉩니다.

### Lock 기반 방식

**Mutex (상호 배제)**
- 한 번에 하나의 스레드만 공유 자원에 접근 가능
- 가장 기본적인 동시성 제어 방식

**Semaphore (세마포어)**
- 여러 스레드가 동시에 접근할 수 있는 자원의 개수를 제한
- 예: 데이터베이스 연결 풀 관리

**Read-Write Lock**
- 읽기 작업은 여러 스레드가 동시에, 쓰기 작업은 하나만
- 읽기 작업이 많은 경우 성능 향상

### Lock-free 방식

**Atomic 연산**
- CPU가 제공하는 원자적 연산 사용
- Lock 없이도 안전한 동시성 보장

**CAS (Compare-And-Swap)**
- 메모리 값과 예상 값을 비교하여 같으면 교체
- Lock 없이 동시성 제어

**Lock-free 자료구조**
- Lock을 사용하지 않는 큐, 스택 등
- 높은 성능과 확장성 제공

### 데이터베이스 락 방식

**비관적 락 (Pessimistic Lock)**
- 데이터를 수정하기 전에 먼저 락을 획득
- 다른 트랜잭션이 동시에 수정하는 것을 방지
- 예: SELECT FOR UPDATE

**낙관적 락 (Optimistic Lock)**
- 락을 사용하지 않고 버전 정보로 충돌 감지
- 충돌이 발생하면 재시도
- 예: 버전 번호나 타임스탬프 사용

**분산 락 (Distributed Lock)**
- 여러 서버 간의 동시성 제어
- Redis, Zookeeper 등을 활용
- 예: Redis의 SETNX 명령어