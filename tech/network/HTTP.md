# HTTP

HTTP(HyperText Transfer Protocol)는 웹에서 데이터를 주고받는 프로토콜입니다.

그리고 특징으로는 아래와 같습니다.

**핵심 특징:**
- **클라이언트-서버 모델**: 브라우저(클라이언트)가 서버에 요청합니다.
- **무상태(Stateless)**: 각 요청은 독립적입니다.
- **요청-응답 방식**: GET, POST, PUT, DELETE 등을 사용합니다.
- **텍스트 기반**: 사람이 읽을 수 있는 형태입니다.

## 🤷🏻‍♂️ 웹 요청에 따른 HTTP 흐름을 설명해 주세요.

### 1. **DNS 조회**
- 브라우저가 도메인을 IP 주소로 변환합니다
- 예: `www.google.com` → `142.250.191.78`

### 2. **TCP 연결 (3-Way Handshake)**
- SYN → SYN-ACK → ACK 과정을 거칩니다
- 클라이언트와 서버 간 연결을 수립합니다

### 3. **HTTP 요청 전송**
```
GET / HTTP/1.1
Host: www.google.com
User-Agent: Mozilla/5.0...
```

### 4. **서버 처리 및 응답**
```
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 1234

<html>...</html>
```

### 5. **연결 종료 (4-Way Handshake)**
- FIN → ACK → FIN → ACK 과정을 거칩니다

## 🤷🏻‍♂️ HTTP 상태 코드를 설명해 주세요.

| 코드 | 의미 | 예시 |
|------|------|------|
| **2xx** | 성공 | 200 OK, 201 Created |
| **3xx** | 리다이렉트 | 301 Moved, 304 Not Modified |
| **4xx** | 클라이언트 오류 | 400 Bad Request, 404 Not Found |
| **5xx** | 서버 오류 | 500 Internal Server Error |

## 🤷🏻‍♂️ HTTP 메서드를 설명해 주세요.

| 메서드 | 의미 | 특징 | 멱등성 | 안전성 |
|--------|------|------|--------|--------|
| **GET** | 데이터 조회 | 캐시 가능, URL에 데이터 노출 | ✅ | ✅ |
| **HEAD** | 헤더 조회 | 본문 없이 헤더만 반환 | ✅ | ✅ |
| **POST** | 데이터 생성 | 캐시 불가, Body에 데이터 | ❌ | ❌ |
| **PUT** | 데이터 수정 | 전체 리소스 교체, 캐시 불가 | ✅ | ❌ |
| **DELETE** | 데이터 삭제 | 캐시 불가 | ✅ | ❌ |
| **PATCH** | 부분 수정 | 일부 리소스만 수정, 캐시 불가 | ❌ | ❌ |
| **TRACE** | 요청 반환 | 요청을 그대로 반환 | ✅ | ✅ |

>**멱등성(Idempotency)이란?**<br>
> 같은 요청을 여러 번 보내도 결과가 동일한 성질을 의미합니다.

**각 메서드별 설명:**
- **GET**: 리소스를 조회합니다. 여러 번 호출해도 같은 데이터를 반환합니다.
- **HEAD**: 리소스의 헤더 정보를 조회합니다. GET과 비슷하지만 본문 데이터는 반환하지 않습니다.
- **PUT**: 리소스를 생성하거나 업데이트합니다. 같은 데이터를 여러 번 요청해도 결과가 동일합니다.
- **DELETE**: 리소스를 삭제합니다. 같은 요청을 반복해도 추가로 삭제되지 않습니다.
- **POST**: 리소스를 생성합니다. 반복 호출 시 리소스가 중복으로 생성될 수 있습니다.
- **PATCH**: 리소스의 일부를 업데이트합니다. 요청에 따라 결과가 달라질 수 있습니다.
- **TRACE**: 요청을 그대로 반환합니다. 요청을 여러 번 보내도 동일한 결과를 가져옵니다.

## 🤷🏻‍♂️ HTTP/1.1에 대해서 설명해주세요.

HTTP/1.0의 경우에는 한 개의 요청과 응답마다 TCP 커넥션을 생성하여 사용됐습니다. 하지만, 이러한 방식은 매 요청마다 연결을 생성하는 오버헤드가 발생합니다. HTTP/1.1은 이러한 문제를 지속 커넥션(Persistent Connection)이라는 지정한 타임아웃만큼 커넥션을 종료하지 않는 방식으로 해결합니다.

또한 파이프라이닝(Pipelining)을 지원하여 요청의 응답 지연을 감소합니다. 파이프라이닝에서 HTTP 요청은 연속적이며, 순차적으로 전달됩니다. 기존에는 요청한 이후에 응답을 기다리고 그 다음 요청을 보냈습니다. 하지만 파이프라이닝에서는 필요한 모든 자원에 대한 요청을 순차적으로 서버로 전송한 다음 모든 요청에 대한 응답을 한 번에 기다리게 됩니다.

HTTP/1.1은 1.0 버전에 비해 상당히 개선됐지만 여전히 문제가 존재합니다. 대표적으로 Head-of-Line Blocking(HOL Blocking) 문제가 있습니다. 만약 3개의 요청을 파이프라인을 통해 전송을 한다고 했을 때, 서버는 모든 요청을 순서에 맞춰서 응답해야 합니다. 이때 첫 번째 요청이 오래 걸린다고 하면, 나머지 요청은 첫 번째 요청의 처리를 기다려야 합니다. 또한, 1.1 버전은 매 요청마다 동일한 헤더를 반복하여 전송한다는 문제점도 존재합니다.

## 🤷🏻‍♂️ HTTP/2.0에 대해서 설명해주세요.

HTTT/1.1는 메시지를 일반 텍스트 형식으로 전송했습니다. 2.0부터는 기존 HTTP 메시지를 프레임이라는 단위로 분할하고 이를 바이너리 형태로 만들어서 전송합니다. 따라서, 기존 1.1 버전에 비해 파싱 및 전송 속도가 향상되었습니다.

또한, HTTP/2.0 부터는 멀티플렉싱(Multiplexing)을 지원합니다. 이는 하나의 커넥션을 사용하여 요청과 응답을 병렬로 처리할 수 있는 방식입니다. 클라이언트가 서버로 여러 요청을 동시에 보내도 각 요청이 독립적으로 처리되기 때문에 애플리케이션 레이어의 HOL Blocking 문제를 해결합니다. 또한 HPACK 헤더 압축 방식을 사용해 반복되는 헤더를 효율적으로 관리하여 대역폭 사용이 최적화되었습니다.

## 🤷🏻‍♂️ HTTP 버전에 따른 비교를 설명해 주세요.

| 버전 | 연도 | 주요 특징 | 연결 방식 | 성능 |
|------|------|-----------|-----------|------|
| **HTTP/1.0** | 1996 | 기본적인 요청-응답 | 연결당 1개 요청 | 느림 |
| **HTTP/1.1** | 1997 | Keep-Alive, 파이프라인 | 연결 재사용 | 개선됨 |
| **HTTP/2** | 2015 | 멀티플렉싱, 헤더 압축 | 단일 연결 | 빠름 |
| **HTTP/3** | 2022 | QUIC 프로토콜, UDP 기반 | 연결 없음 | 매우 빠름 |

**핵심 개선사항:**
- **HTTP/1.1**: Keep-Alive로 연결 재사용하여 성능을 향상시킵니다.
- **HTTP/2**: 멀티플렉싱으로 동시 요청을 처리합니다. (병렬 처리)
- **HTTP/3**: UDP 기반으로 연결 설정 시간을 단축합니다. (빠른 연결)

## 🤷🏻‍♂️ HTTP vs HTTPS 차이점은?

| 구분 | HTTP | HTTPS |
|------|------|-------|
| **보안** | 평문 전송 | 암호화 전송 |
| **포트** | 80 | 443 |
| **인증서** | 불필요 | SSL/TLS 인증서 필요 |
| **성능** | 빠름 | 약간 느림 (암호화 오버헤드) |