# Dockerfile이란?

Docker 이미지는 Dockerhub을 통해 다운받아서 사용할 수 있다. 이 Docker 이미지들도 누군가 만들어서 Dockerhub에 올려놓은 것입니다. 그리고 이 Dcoker 이미지는 **Dockerfile**이라는 걸 활용해서 Docker 이미지를 만들 수 있습니다. Dockerhub에 올려놓은 Docker 이미지가 아닌, 자신만의 Docker 이미지를 만들고 싶을 수 있습니다. 

정리하자면, **Dockerfile**이란 **Docker 이미지를 만들게 해주는 파일**입니다.

## 🤷🏻‍♂️ FROM이 무엇인가요?

FROM은 베이스 이미지를 생성하는 역할을 합니다. 그리고 Docker 컨테이너를 특정 초기 이미지를 기반으로 추가적인 셋팅을 할 수 있습니다. 여기서 얘기한 ‘특정 초기 이미지’는 기초가 될 이미지를 뜻합니다.

쉽게 예를 들어보겠습니다. 

윈도우 컴퓨터를 새로 사서 실행시켜보면 기본 프로그램들(인터넷, 그림판, 메모장 등)이 많이 깔려있습니다. 베이스 이미지도 이와 똑같습니다. 컨테이너를 새로 띄워서 미니 컴퓨터 환경을 구축할 때 기본 프로그램이 어떤게 깔려있으면 좋겠는 지 선택하는 옵션이라고 생각하면 됩니다.
누군가는 JDK가 깔려있는 컴퓨터 환경이 셋팅되기를 바랄 수도 있고, 누군가는 Node가 깔려있는 컴퓨터 환경이 셋팅되기를 바랄 수도 있습니다. 그렇기 때문에 필요에 따라 베이스 이미지를 고르면 됩니다.

```dockerfile
FROM [이미지명]
FROM [이미지명]:[태그명]
```

- `태그명`을 적지 않으면 해당 이미지의 최신(latest) 버전을 사용합니다.

## 🤷🏻‍♂️ # 종료된 컨테이너에 들어가서 디버깅하고 싶을 때, 어떻게 하나요?

- `docker logs`를 활용해 컨테이너 로그 확인하기
- `docker exec -it`를 활용해 컨테이너 내부에 직접 들어가보기

하지만 이미지를 만들면서 컨테이너를 실행시켜보면, 컨테이너의 특성상 명령어 처리가 다 끝나는대로 컨테이너가 종료됩니다. 그러다보니 내부적으로 어떻게 컨테이너가 형성됐는 지 디버깅을 하는데 어려움을 겪습니다.

이를 해결하기 위해 아래와 같이 명령어를 작성해 주면 됩니다.

```dockerfile
FROM openjdk:17-jdk

...

ENTRYPOINT ["/bin/bash", "-c", "sleep 500"] # 500초 동안 시스템을 일시정지 시키는 명령어
```

위 명령어를 추가함으로써 컨테이너가 바로 종료되는 걸 막을 수 있습니다. 그런 뒤에 docker exec -it를 활용해 컨테이너 내부에 직접 들어가서 디버깅을 하면 됩니다.

## 🤷🏻‍♂️ COPY가 무엇인가요?

`COPY`는 **호스트 컴퓨터**에 있는 파일을 복사해서 **컨테이너**로 전달합니다.

```dockerfile
# 문법
COPY [호스트 컴퓨터에 있는 복사할 파일의 경로] [컨테이너에서 파일이 위치할 경로]

# 예시
COPY app.txt /app.txt
```

만약 폴더를 만들어서 관리하고 싶다면, 아래와 같이 작성하면 됩니다.

```dockerfile
FROM ubuntu

COPY my-app /my-app/

ENTRYPOINT ["/bin/bash", "-c", "sleep 500"] # 디버깅용 코드
```

만약 와일드 카드를 사용해서 관리하고 싶다면, 아래와 같이 작성하면 됩니다.

```dockerfile
FROM ubuntu

COPY *.txt /text-files/

ENTRYPOINT ["/bin/bash", "-c", "sleep 500"] # 디버깅용 코드
```

만약 올리고 싶지 않은 파일들이 있다면, `.dockerignore`를 사용하면 됩니다.