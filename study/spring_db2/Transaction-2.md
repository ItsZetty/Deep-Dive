# Transaction 전파

트랜잭션 전파는 트랜잭션이 이미 존재할 때 새 트랜잭션이 생성될지, 기존 트랜잭션에 참여할지를 결정하는 규칙입니다. 그리고 스프링의 기본 전파 옵션은 REQUIRED입니다.

## 논리 트랜잭션 vs 물리 트랜잭션
- 논리 트랜잭션 : 스프링의 트랜잭션 매니저 단위의 트랜잭션
- 물리 트랜잭션 : 실제 DB 커넥션 단위의 트랜잭션

모든 논리 트랜잭션이 커밋되어야 물리 트랜잭션도 커밋됩니다. 그리고 하나라도 롤백되면 물리 트랜잭션 전체가 롤백됩니다.

## 트랜잭션 전파의 기본 동작

- 트랜잭션이 없는 상태에서 `@Transactional` 메서드를 호출하면 새 트랜잭션이 생성됩니다.
- 이미 트랜잭션이 존재하면, 내부 트랜잭션은 외부 트랜잭션에 참여(Participate)하며 하나의 물리 트랜잭션으로 묶입니다.
- 실제 커밋/롤백은 외부 트랜잭션에서만 수행됩니다.
- 내부 트랜잭션이 롤백되면 전체 트랜잭션이 `rollback-only` 상태가 되어, 외부 트랜잭션이 커밋을 시도할 때 `UnexpectedRollbackException`이 발생합니다.

## 전파 동작의 주요 원칙

- 외부 트랜잭션이 커밋되고 내부도 커밋 : 전체 커밋
- 외부 트랜잭션이 롤백 : 전체 롤백
- 내부 트랜잭션이 롤백 : 전체 롤백 (`rollback-only` 플래그 설정)
- 내부 트랜잭션이 커밋, 외부가 롤백 : 전체 롤백

즉, 내부든 외부든 하나라도 실패하면 전체 롤백되는 구조입니다.

## 트랜잭션 전파 활용

트랜잭션 전파는 실제 서비스 계층에서 트랜잭션 범위를 유연하게 제어하기 위해 사용됩니다.

### 1️⃣ 서비스 계층에 트랜잭션이 없는 경우
- 각 리포지토리가 각각 트랜잭션을 가짐
- 하나는 커밋, 하나는 롤백될 수 있음 → 데이터 불일치 발생 가능

### 2️⃣ 서비스 계층에만 트랜잭션이 있는 경우
- 하나의 트랜잭션 범위로 묶임
- 내부 리포지토리는 모두 동일한 커넥션을 사용
- 가장 깔끔하고 일반적인 구조 (서비스 단에서 트랜잭션 관리)

### 3️⃣ 모든 계층에 트랜잭션이 있는 경우 (기본 전파 `REQUIRED`)
- 이미 트랜잭션이 존재하면 내부 트랜잭션은 참여
- 외부 트랜잭션이 실제 물리 트랜잭션을 관리
- 내부에서 예외 발생 시 `rollbackOnly`가 설정되어 전체 롤백

## 예외 복구와 전파 옵션
`REQUIRED(기본값)` : 기존 트랜잭션에 참여 / 없으면 새로 생성 | 내부 예외 시 전체 롤백, 복구 불가
`REQUIRES_NEW` : 항상 새로운 트랜잭션 생성 (외부와 분리) | 내부 트랜잭션만 롤백, 외부는 정상 커밋 가능


로그 저장과 같이 실패해도 전체 작업에 영향 주지 않아야 하는 경우, REQUIRES_NEW를 사용해 분리할 수 있습니다.

